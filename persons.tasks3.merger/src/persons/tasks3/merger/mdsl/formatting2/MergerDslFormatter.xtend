/*
 * generated by Xtext 2.25.0
 */
package persons.tasks3.merger.mdsl.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument
import persons.tasks3.merger.mdsl.mergerDsl.Planning
import persons.tasks3.merger.mdsl.mergerDsl.Task
import persons.tasks3.merger.mdsl.services.MergerDslGrammarAccess
import org.eclipse.xtext.TerminalRule
import org.eclipse.xtext.AbstractRule
import org.eclipse.xtext.formatting2.regionaccess.IComment
import java.util.List


class MergerDslFormatter extends AbstractFormatter2 {
	
	@Inject extension MergerDslGrammarAccess

	def dispatch void format(Planning planning, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc.
		
		
	println(textRegionAccess);
 	println("----------------------------------------------THE END in MERGER---------------------------------------------------------------------");

    var i=0;
    var current = textRegionAccess.regionForRootEObject().getPreviousHiddenRegion();
	while (current !== null) 
	{
		if (current.containsComment())
		{
		var current2 = current.getParts();
		val currentIterator = current2.iterator();
		while (currentIterator.hasNext())
		 {	
		    var b= currentIterator.next();
			if (b.getGrammarElement() instanceof TerminalRule) 
			{
			 if ((b.getGrammarElement() as AbstractRule).getName().startsWith("WS"))
			 {println("whitespace detected");}
			  else {
			    var a=b as IComment; 
				println("getText(): "+a.getText());
				println("getLineCount(): "+a.getLineCount()); 
				println("getLineRegions(): "+a.getLineRegions());
				println("getGrammarElement(): "+a.getGrammarElement());
				println("getEndOffset(): "+a.getEndOffset());
				println("getAssociation(): "+a.getAssociation());
				
				val grammarElement = a.getGrammarElement();
   			    if (grammarElement instanceof AbstractRule) 
    			{
        			val ruleName = (grammarElement as AbstractRule).getName();
        			if (ruleName.startsWith("ML"))
        				{println("ML");
          			  //new MultilineCommentReplacer(a, '*');
          			  }
       				if (ruleName.startsWith("SL"))
       				  {println("SL");
        				if (a.getLineRegions().get(0).getIndentation().getLength() > 0) {println("SL1");
          			    //new SinglelineDocCommentReplacer(a, "//");
          			    }
          		   // else
            		 //    new SinglelineCodeCommentReplacer(a, "//");
        		}
    		 }
			
		  }
		 }
		}	
	}
	 println(current.containsComment()+"   ................................."+i+"................................................................");i=i+1;
	 current = current.getNextHiddenRegion();
 }       
        
	//-------------------------------- Removing Empty Lines from DSL ----------------------------
	
		val lastEntity = planning.persons.last
		for (person : planning.persons) 
		  {
			person.format
			if (person === lastEntity)
		    person.append[setNewLines(1)]
		    else  
            person.prepend[noSpace; noAutowrap].append[setNewLines(0, 1, 1)]
            
            //person.setColor(new RGB(63, 95, 191));
            
            //println("planning.persons: "+sortInplace(planning.persons as List));
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		
		val lastEntity2 = planning.tasks.last
		for (task : planning.tasks) 
		{
			task.format
			if (task === lastEntity2)
			task.append[setNewLines(1)]
			else
		    task.prepend[noSpace; noAutowrap].append[setNewLines(0, 1, 1)]
		}
		/////////////////////////////////////////////////////////////////////////////////////////
			val lastEntity3 = textRegionAccess.regionForRootEObject().getSemanticRegions()
			for (task : lastEntity3) 
			{
			 task.format
		     task.append[setNewLines(0, 1, 1)]
			}
		
	/*	for (person : planning.persons) {
			person.format
		}
		for (task : planning.tasks) {
			task.format
		} */
	}

 /*	def dispatch void format(Task task, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		task.action.format
	} */
	
}
