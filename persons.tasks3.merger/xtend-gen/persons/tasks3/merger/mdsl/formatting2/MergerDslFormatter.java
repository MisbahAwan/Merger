/**
 * generated by Xtext 2.25.0
 */
package persons.tasks3.merger.mdsl.formatting2;

import com.google.inject.Inject;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.AbstractRule;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.HiddenRegionPartAssociation;
import org.eclipse.xtext.formatting2.regionaccess.IComment;
import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegion;
import org.eclipse.xtext.formatting2.regionaccess.IHiddenRegionPart;
import org.eclipse.xtext.formatting2.regionaccess.ILineRegion;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import persons.tasks3.merger.mdsl.mergerDsl.Person;
import persons.tasks3.merger.mdsl.mergerDsl.Planning;
import persons.tasks3.merger.mdsl.mergerDsl.Task;
import persons.tasks3.merger.mdsl.services.MergerDslGrammarAccess;

@SuppressWarnings("all")
public class MergerDslFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private MergerDslGrammarAccess _mergerDslGrammarAccess;
  
  protected void _format(final Planning planning, @Extension final IFormattableDocument document) {
    InputOutput.<ITextRegionAccess>println(this.getTextRegionAccess());
    InputOutput.<String>println("----------------------------------------------THE END in MERGER---------------------------------------------------------------------");
    int i = 0;
    IHiddenRegion current = this.getTextRegionAccess().regionForRootEObject().getPreviousHiddenRegion();
    while ((current != null)) {
      {
        boolean _containsComment = current.containsComment();
        if (_containsComment) {
          List<IHiddenRegionPart> current2 = current.getParts();
          final Iterator<IHiddenRegionPart> currentIterator = current2.iterator();
          while (currentIterator.hasNext()) {
            {
              IHiddenRegionPart b = currentIterator.next();
              EObject _grammarElement = b.getGrammarElement();
              if ((_grammarElement instanceof TerminalRule)) {
                EObject _grammarElement_1 = b.getGrammarElement();
                boolean _startsWith = ((AbstractRule) _grammarElement_1).getName().startsWith("WS");
                if (_startsWith) {
                  InputOutput.<String>println("whitespace detected");
                } else {
                  IComment a = ((IComment) b);
                  String _text = a.getText();
                  String _plus = ("getText(): " + _text);
                  InputOutput.<String>println(_plus);
                  int _lineCount = a.getLineCount();
                  String _plus_1 = ("getLineCount(): " + Integer.valueOf(_lineCount));
                  InputOutput.<String>println(_plus_1);
                  List<ILineRegion> _lineRegions = a.getLineRegions();
                  String _plus_2 = ("getLineRegions(): " + _lineRegions);
                  InputOutput.<String>println(_plus_2);
                  EObject _grammarElement_2 = a.getGrammarElement();
                  String _plus_3 = ("getGrammarElement(): " + _grammarElement_2);
                  InputOutput.<String>println(_plus_3);
                  int _endOffset = a.getEndOffset();
                  String _plus_4 = ("getEndOffset(): " + Integer.valueOf(_endOffset));
                  InputOutput.<String>println(_plus_4);
                  HiddenRegionPartAssociation _association = a.getAssociation();
                  String _plus_5 = ("getAssociation(): " + _association);
                  InputOutput.<String>println(_plus_5);
                  final EObject grammarElement = a.getGrammarElement();
                  if ((grammarElement instanceof AbstractRule)) {
                    final String ruleName = ((AbstractRule) grammarElement).getName();
                    boolean _startsWith_1 = ruleName.startsWith("ML");
                    if (_startsWith_1) {
                      InputOutput.<String>println("ML");
                    }
                    boolean _startsWith_2 = ruleName.startsWith("SL");
                    if (_startsWith_2) {
                      InputOutput.<String>println("SL");
                      int _length = a.getLineRegions().get(0).getIndentation().getLength();
                      boolean _greaterThan = (_length > 0);
                      if (_greaterThan) {
                        InputOutput.<String>println("SL1");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        boolean _containsComment_1 = current.containsComment();
        String _plus = (Boolean.valueOf(_containsComment_1) + "   .................................");
        String _plus_1 = (_plus + Integer.valueOf(i));
        String _plus_2 = (_plus_1 + "................................................................");
        InputOutput.<String>println(_plus_2);
        i = (i + 1);
        current = current.getNextHiddenRegion();
      }
    }
    final Person lastEntity = IterableExtensions.<Person>last(planning.getPersons());
    EList<Person> _persons = planning.getPersons();
    for (final Person person : _persons) {
      {
        document.<Person>format(person);
        if ((person == lastEntity)) {
          final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
            it.setNewLines(1);
          };
          document.<Person>append(person, _function);
        } else {
          final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
            it.noSpace();
            it.noAutowrap();
          };
          final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
            it.setNewLines(0, 1, 1);
          };
          document.<Person>append(document.<Person>prepend(person, _function_1), _function_2);
        }
      }
    }
    final Task lastEntity2 = IterableExtensions.<Task>last(planning.getTasks());
    EList<Task> _tasks = planning.getTasks();
    for (final Task task : _tasks) {
      {
        document.<Task>format(task);
        if ((task == lastEntity2)) {
          final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
            it.setNewLines(1);
          };
          document.<Task>append(task, _function);
        } else {
          final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
            it.noSpace();
            it.noAutowrap();
          };
          final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
            it.setNewLines(0, 1, 1);
          };
          document.<Task>append(document.<Task>prepend(task, _function_1), _function_2);
        }
      }
    }
    final Iterable<ISemanticRegion> lastEntity3 = this.getTextRegionAccess().regionForRootEObject().getSemanticRegions();
    for (final ISemanticRegion task_1 : lastEntity3) {
      {
        document.<ISemanticRegion>format(task_1);
        final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
          it.setNewLines(0, 1, 1);
        };
        document.append(task_1, _function);
      }
    }
  }
  
  public void format(final Object planning, final IFormattableDocument document) {
    if (planning instanceof XtextResource) {
      _format((XtextResource)planning, document);
      return;
    } else if (planning instanceof Planning) {
      _format((Planning)planning, document);
      return;
    } else if (planning instanceof EObject) {
      _format((EObject)planning, document);
      return;
    } else if (planning == null) {
      _format((Void)null, document);
      return;
    } else if (planning != null) {
      _format(planning, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(planning, document).toString());
    }
  }
}
